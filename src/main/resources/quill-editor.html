<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://cdn.quilljs.com/1.3.6/quill.snow.css" rel="stylesheet">
    <script src="https://cdn.quilljs.com/1.3.6/quill.min.js"></script>
    <style id="theme-styles"></style>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
            overflow: hidden;
        }
        #editor {
            height: calc(100vh - 42px);
            min-height: 400px;
        }
        .ql-container {
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 14px;
            height: 100%;
            overflow-y: auto !important; /* WICHTIG: Scrollbalken anzeigen */
            overflow-x: hidden !important;
        }
        /* WICHTIG: Stelle sicher, dass Scrollbalken auch mit Quill's Standard-Klassen sichtbar ist */
        .ql-snow .ql-container,
        .ql-container.ql-snow {
            overflow-y: auto !important;
            overflow-x: hidden !important;
        }
        /* Globale Schriftgröße und Schriftart für Editor */
        .ql-editor {
            font-size: 14px;
            font-family: 'Consolas', 'Monaco', monospace;
        }
        .ql-editor {
            min-height: 100%;
            padding: 15px 30px 15px 15px; /* oben, rechts, unten, links - rechts mehr Platz für schönen Rand */
            /* Erhöhter Absatzabstand */
            line-height: 1.6;
        }
        /* Absatzabstand erhöhen */
        .ql-editor p {
            margin-top: 0.75em;
            margin-bottom: 0.75em;
            /* WICHTIG: Keine text-align-Override hier, damit align-Modul funktioniert */
        }
        /* Blocksatz mit besserem Abstand */
        .ql-editor p[style*="text-align: justify"] {
            text-align: justify !important;
            text-align-last: left !important;
            word-spacing: 0.1em;
        }
        /* Zentrierte Absätze - unterstütze sowohl class als auch style */
        /* WICHTIG: Höhere Spezifität verwenden, damit es andere Regeln überschreibt */
        .ql-container .ql-snow .ql-editor p.ql-align-center,
        .ql-container .ql-snow .ql-editor p[style*="text-align: center"],
        .ql-container .ql-snow .ql-editor p[data-align="center"],
        .ql-editor p.ql-align-center,
        .ql-editor p[style*="text-align: center"],
        .ql-editor p[data-align="center"] {
            text-align: center !important;
        }
        /* Stelle sicher, dass Quill's eigene align-Klassen funktionieren */
        .ql-snow .ql-editor .ql-align-center,
        .ql-editor .ql-align-center {
            text-align: center !important;
        }
        /* Blockquote-Styling: Einrückung, Kursivschrift, grau - kein Strich links */
        .ql-editor blockquote {
            border-left: none !important;
            padding-left: 2em !important;
            font-style: italic !important;
            color: #666666 !important;
            margin-left: 0 !important;
            margin-right: 0 !important;
        }
        /* Horizontale Linien (hr und div mit border-top) */
        .ql-editor hr {
            border: none !important;
            border-top: 2px solid #bdc3c7 !important;
            margin: 20px 0 !important;
            height: 0 !important;
            display: block !important;
            width: 100% !important;
        }
        /* Div-basierte horizontale Linien (für Quill-Kompatibilität) */
        .ql-editor div[style*="border-top"] {
            border-top: 2px solid #bdc3c7 !important;
            margin: 20px 0 !important;
            height: 0 !important;
            overflow: hidden !important;
            display: block !important;
            width: 100% !important;
        }
        /* Dropdown-Labels (oben, nicht ausgeklappt) - Textfarbe korrigieren */
        .ql-toolbar .ql-picker-label {
            color: #444 !important;
        }
        .ql-toolbar .ql-color .ql-picker-label,
        .ql-toolbar .ql-background .ql-picker-label,
        .ql-toolbar .ql-font .ql-picker-label,
        .ql-toolbar .ql-size .ql-picker-label,
        .ql-toolbar .ql-align .ql-picker-label,
        .ql-toolbar .ql-header .ql-picker-label {
            color: #444 !important;
        }
        /* Dropdown-Optionen (ausgeklappt) */
        .ql-toolbar .ql-picker-options {
            background-color: #fff !important;
            border: 1px solid #ccc !important;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15) !important;
        }
        .ql-toolbar .ql-picker-options .ql-picker-item {
            color: #444 !important;
        }
        .ql-toolbar .ql-picker-item:hover {
            background-color: #f0f0f0 !important;
            color: #000 !important;
        }
        .ql-toolbar .ql-picker-item.ql-selected {
            background-color: #e0e0e0 !important;
            color: #000 !important;
        }
        #error-message {
            padding: 20px;
            background-color: #ffebee;
            border: 2px solid #f44336;
            margin: 20px;
        }
    </style>
</head>
<body>
    <div id="editor"></div>
    <div id="error-message" style="display: none; padding: 20px; color: red; font-family: Arial, sans-serif;">
        <h2>Fehler beim Laden des Quill Editors</h2>
        <p>Bitte prüfen Sie die Browser-Konsole für Details.</p>
    </div>
    <script>
        // Logging-Funktion über Java-Bridge (wird später gesetzt, aber hier schon definiert)
        function logToJava(level, message) {
            try {
                // Initialisiere quillLogs Array falls nicht vorhanden
                if (!window.quillLogs) {
                    window.quillLogs = [];
                }
                
                // Speichere Log in Array (wird später von Java abgerufen)
                window.quillLogs.push({
                    level: level,
                    message: message,
                    time: new Date().toISOString()
                });
                
                // Begrenze Array-Größe auf 100 Einträge
                if (window.quillLogs.length > 100) {
                    window.quillLogs.shift();
                }
                
                // Versuche auch direkt über Bridge zu loggen (falls verfügbar)
                if (window.javaApp && window.javaApp.log) {
                    window.javaApp.log(level, message);
                }
            } catch (e) {
                // Fallback: Ignoriere Logging-Fehler
            }
        }

        
        
        // Prüfe ob Quill verfügbar ist
        if (typeof Quill === 'undefined') {
            document.getElementById('error-message').style.display = 'block';
            document.getElementById('editor').style.display = 'none';
            logToJava('ERROR', 'Quill wurde nicht geladen! Bitte prüfen Sie die Netzwerk-Verbindung.');
        }
        
        // WICHTIG: Benutzerdefiniertes Blot für horizontale Linien registrieren
        // Quill unterstützt standardmäßig keine <hr> Tags
        if (typeof Quill !== 'undefined') {
            const BlockEmbed = Quill.import('blots/block/embed');
            
            class HorizontalRuleBlot extends BlockEmbed {
                static create() {
                    let node = super.create();
                    node.setAttribute('style', 'border: none; border-top: 2px solid #bdc3c7; margin: 20px 0; height: 0; overflow: hidden; display: block; width: 100%;');
                    return node;
                }
                
                static value() {
                    return {};
                }
            }
            // WICHTIG: Stelle sicher, dass das Blot korrekt erkannt wird
            HorizontalRuleBlot.blotName = 'hr';
            HorizontalRuleBlot.tagName = 'hr';
            
            Quill.register(HorizontalRuleBlot, true);
            logToJava('DEBUG', 'HorizontalRuleBlot registriert');
        }
        
        var quill;
        try {
            // Prüfe ob align-Modul verfügbar ist
            try {
                var AlignClass = Quill.import('formats/align');
                logToJava('DEBUG', 'Align-Modul gefunden: ' + (AlignClass ? 'ja' : 'nein'));
                if (AlignClass) {
                    logToJava('DEBUG', 'Align-Whitelist: ' + JSON.stringify(AlignClass.whitelist));
                }
            } catch (e) {
                logToJava('ERROR', 'Align-Modul nicht verfügbar: ' + e.message);
            }
            
            quill = new Quill('#editor', {
            theme: 'snow',
            modules: {
                toolbar: [
                    // [{ 'font': [] }], // ENTFERNT - Schriftart-Dropdown
                    // [{ 'size': ['small', false, 'large', 'huge'] }], // ENTFERNT - Größe-Dropdown
                    ['bold', 'italic', 'underline', 'strike'],
                    [{ 'script': 'sub'}, { 'script': 'super' }],
                    ['blockquote', 'code-block'],
                    [{ 'align': [] }], // Aktiviert - Absatzformat-Button für Zentrierung
                    ['link'],
                    ['hr'], // Horizontale Linie
                    ['clean']
                ]
            }
            });

            
            
            // Prüfe ob align-Modul nach Initialisierung verfügbar ist
            try {
                var alignModule = quill.getModule('align');
                logToJava('DEBUG', 'Align-Modul nach Init: ' + (alignModule ? 'verfügbar' : 'nicht verfügbar'));
            } catch (e) {
                logToJava('ERROR', 'Align-Modul nach Init nicht verfügbar: ' + e.message);
            }
            
            // WICHTIG: Handler für horizontale Linien-Button hinzufügen
            var toolbar = quill.getModule('toolbar');
            toolbar.addHandler('hr', function() {
                var range = quill.getSelection(true);
                if (range) {
                    // Verwende insertEmbed mit dem registrierten Blot
                    quill.insertEmbed(range.index, 'hr', {}, 'user');
                    quill.setSelection(range.index + 1, 'silent');
                } else {
                    // Fallback: Füge am Ende ein
                    var length = quill.getLength();
                    quill.insertEmbed(length - 1, 'hr', {}, 'user');
                }
            });
        } catch (e) {
            logToJava('ERROR', 'Fehler beim Initialisieren von Quill: ' + e.message);
            document.getElementById('error-message').style.display = 'block';
            document.getElementById('editor').style.display = 'none';
            throw e;
        }
        
        // Stelle sicher, dass logToJava auch hier verfügbar ist
        if (typeof logToJava === 'undefined') {
            function logToJava(level, message) {
                try {
                    if (!window.quillLogs) {
                        window.quillLogs = [];
                    }
                    window.quillLogs.push({
                        level: level,
                        message: message,
                        time: new Date().toISOString()
                    });
                    if (window.quillLogs.length > 100) {
                        window.quillLogs.shift();
                    }
                } catch (e) {
                    // Ignoriere Fehler
                }
            }
        }
        
        // Java Bridge für bidirektionale Kommunikation
        // Verwende Polling-Mechanismus (window.javaApp wird von Java-Seite gesetzt)
        function sendContentToJava(content, delta) {
            try {
                // Verwende die von Java gesetzte Bridge
                if (window.javaApp && window.javaApp.onQuillContentChange) {
                    window.javaApp.onQuillContentChange(content, delta);
                } else {
                    // Fallback: Setze Flags für Polling
                    window.quillLastContent = content;
                    window.quillLastDelta = delta;
                    window.quillContentChanged = true;
                }
            } catch (e) {
                logToJava('ERROR', 'Error sending content to Java: ' + e.message);
                // Fallback: Setze Flags für Polling
                window.quillLastContent = content;
                window.quillLastDelta = delta;
                window.quillContentChanged = true;
            }
        }
        
        function sendScrollToJava(scrollTop, scrollHeight) {
            try {
                if (window.javaApp && window.javaApp.onQuillScroll) {
                    window.javaApp.onQuillScroll(scrollTop, scrollHeight);
                } else {
                    // Fallback: Setze Flags für Polling
                    window.quillLastScroll = {top: scrollTop, height: scrollHeight};
                    window.quillScrollChanged = true;
                }
            } catch (e) {
                logToJava('ERROR', 'Error sending scroll to Java: ' + e.message);
                // Fallback: Setze Flags für Polling
                window.quillLastScroll = {top: scrollTop, height: scrollHeight};
                window.quillScrollChanged = true;
            }
        }
        
        // Text-Änderungen abfangen
        if (quill) {
            // WICHTIG: Automatische Konvertierung von --- zu horizontaler Linie
            // Verwende setTimeout für verzögerte Prüfung, damit der Text vollständig eingegeben ist
            var hrConversionTimeout = null;
            
            // WICHTIG: format-change Event-Listener DEAKTIVIERT - verursacht Performance-Probleme
            // Nur bei Bedarf wieder aktivieren für Debugging
            /*
            quill.on('editor-change', function(name, ...args) {
                if (name === 'format-change') {
                    var format = args[0];
                    if (format && format.align !== undefined) {
                        logToJava('DEBUG', 'Format-Change erkannt: align=' + format.align);
                    }
                }
            });
            */
            
            quill.on('text-change', function(delta, oldDelta, source) {
                // WICHTIG: Ignoriere Events während programmatischer Updates (verhindert Feedback-Schleife)
                // Dies muss GANZ AM ANFANG stehen, bevor irgendwelche anderen Checks
                // Prüfe das Flag ZUERST, bevor irgendetwas anderes passiert
                if (window.isUpdatingFromCodeArea === true) {
                    logToJava('DEBUG', 'Quill text-change IGNORIERT (programmatisches Update läuft, source: ' + source + ')');
                    return; // WICHTIG: return verhindert ALLE weitere Verarbeitung, auch für User-Events
                }
                
                // WICHTIG: Automatische Konvertierung von --- zu horizontaler Linie
                // Nur für User-Events, nicht für API-Events
                if (source === 'user') {
                    // Lösche vorherigen Timeout
                    if (hrConversionTimeout) {
                        clearTimeout(hrConversionTimeout);
                    }
                    
                    // Prüfe nach kurzer Verzögerung (100ms)
                    hrConversionTimeout = setTimeout(function() {
                        try {
                            var text = quill.getText();
                            var cursorPos = quill.getSelection(true);
                            
                            if (cursorPos) {
                                // Finde die aktuelle Zeile
                                var lineStart = text.lastIndexOf('\n', cursorPos.index - 1);
                                if (lineStart === -1) lineStart = 0;
                                else lineStart = lineStart + 1;
                                
                                var lineEnd = text.indexOf('\n', cursorPos.index);
                                if (lineEnd === -1) lineEnd = text.length;
                                
                                var lineText = text.substring(lineStart, lineEnd).trim();
                                
                                // Prüfe ob die Zeile genau "---", "***" oder "___" ist
                                if (lineText === '---' || lineText === '***' || lineText === '___') {
                                    // Ersetze die Zeile durch horizontale Linie
                                    var deleteLength = lineEnd - lineStart;
                                    quill.deleteText(lineStart, deleteLength, 'api');
                                    quill.insertEmbed(lineStart, 'hr', {}, 'api');
                                    quill.insertText(lineStart + 1, '\n', 'api');
                                    quill.setSelection(lineStart + 2, 'api');
                                    return; // Verhindere weitere Verarbeitung
                                }
                            }
                        } catch (e) {
                            logToJava('ERROR', 'Fehler bei hr-Konvertierung: ' + e.message);
                        }
                    }, 100);
                }
                
                // WICHTIG: Nur User-Änderungen synchronisieren, nicht API-Änderungen
                // ABER: Wenn isUpdatingFromCodeArea gesetzt ist, ignoriere ALLE Events (auch user-Events)
                // Das verhindert, dass programmatische Updates Events auslösen, die zurück zum Editor syncen
                if (source === 'user' && !window.isUpdatingFromCodeArea) {
                    var content = quill.root.innerHTML;
                    var deltaJson = JSON.stringify(delta);
                    logToJava('DEBUG', 'Quill text-change erkannt (user), Content-Länge: ' + content.length);
                    sendContentToJava(content, deltaJson);
                } else {
                    if (window.isUpdatingFromCodeArea) {
                        logToJava('DEBUG', 'Quill text-change ignoriert (programmatisches Update läuft, source: ' + source + ')');
                    } else {
                        logToJava('DEBUG', 'Quill text-change ignoriert (source: ' + source + ')');
                    }
                }
            });
            
            // WICHTIG: Debug-Handler für align-Button-Klicks
            var toolbar = quill.getModule('toolbar');
            if (toolbar) {
                // Überwache align-Button-Klicks - verwende Event-Delegation für Dropdown
                var toolbarContainer = toolbar.container;
                if (toolbarContainer) {
                    logToJava('DEBUG', 'Toolbar-Container gefunden, füge Event-Listener hinzu');
                   
                    // WICHTIG: Event-Listener DEAKTIVIERT - verursacht Performance-Probleme
                    // Nur bei Bedarf wieder aktivieren für Debugging
                    /*
                    toolbarContainer.addEventListener('click', function(e) {
                        var target = e.target;
                        // Prüfe ob es ein align-Button oder align-Dropdown-Item ist
                        if (target.classList.contains('ql-align') || target.closest('.ql-align')) {
                            var value = target.getAttribute('value') || (target.closest('.ql-picker-item') ? target.closest('.ql-picker-item').getAttribute('data-value') : 'dropdown');
                            logToJava('DEBUG', 'Align-Button/Dropdown wurde geklickt, value: ' + value);
                            
                            setTimeout(function() {
                                var selection = quill.getSelection(true);
                                if (selection) {
                                    var format = quill.getFormat(selection);
                                    logToJava('DEBUG', 'Format nach Button-Klick: ' + JSON.stringify(format));
                                    
                                    // Prüfe auch das DOM-Element
                                    try {
                                        var line = quill.getLine(selection.index);
                                        if (line && line.length > 0) {
                                            var domNode = line[0].domNode;
                                            if (domNode) {
                                                logToJava('DEBUG', 'DOM-Element classes: ' + domNode.className);
                                                logToJava('DEBUG', 'DOM-Element style: ' + domNode.getAttribute('style'));
                                                logToJava('DEBUG', 'DOM-Element computed style text-align: ' + window.getComputedStyle(domNode).textAlign);
                                            }
                                        }
                                    } catch (e) {
                                        logToJava('ERROR', 'Fehler beim Prüfen des DOM-Elements: ' + e.message);
                                    }
                                }
                            }, 300);
                        }
                    });
                    */
                } else {
                    logToJava('WARN', 'Toolbar-Container nicht gefunden!');
                }
            }
            
            // Selektion-Änderungen abfangen
            quill.on('selection-change', function(range) {
                if (window.javaApp) {
                    try {
                        if (range) {
                            window.javaApp.onQuillSelectionChange(range.index, range.length);
                        } else {
                            window.javaApp.onQuillSelectionChange(-1, 0);
                        }
                    } catch (e) {
                        logToJava('ERROR', 'Error sending selection to Java: ' + e.message);
                    }
                }
            });
            
            // WICHTIG: MutationObserver DEAKTIVIERT - verursacht Performance-Probleme
            // Der Observer wurde deaktiviert, da er zu viele DOM-Updates auslöst und den Editor blockiert
            // Zentrierung wird stattdessen nur beim Setzen des Contents angewendet
            /*
            var observer = new MutationObserver(function(mutations) {
                mutations.forEach(function(mutation) {
                    if (mutation.type === 'childList' || mutation.type === 'attributes') {
                        var editor = quill.root;
                        var centerParagraphs = editor.querySelectorAll('p.ql-align-center, p[style*="text-align: center"]');
                        centerParagraphs.forEach(function(p) {
                            // Stelle sicher, dass Zentrierung immer gesetzt ist
                            if (p.style.textAlign !== 'center') {
                                p.style.textAlign = 'center';
                                p.style.setProperty('text-align', 'center', 'important');
                            }
                        });
                    }
                });
            });
            
            // Starte Observer nach kurzer Verzögerung
            setTimeout(function() {
                if (quill && quill.root) {
                    observer.observe(quill.root, {
                        childList: true,
                        subtree: true,
                        attributes: true,
                        attributeFilter: ['style', 'class']
                    });
                }
            }, 500);
            */
            
            // Scroll-Events abfangen
            setTimeout(function() {
                var scrollContainer = document.querySelector('.ql-editor');
                if (scrollContainer) {
                    scrollContainer.addEventListener('scroll', function() {
                        // WICHTIG: Ignoriere Scroll-Events während programmatischer Updates (verhindert Feedback-Schleife)
                        // Wenn isUpdatingFromCodeArea gesetzt ist, wurde der Content gerade programmatisch gesetzt
                        // und wir sollten NICHT zurück zum Editor synchronisieren (verhindert Zucken)
                        if (window.isUpdatingFromCodeArea) {
                            return; // Ignoriere Scroll-Event komplett während programmatischer Updates
                        }
                        
                        // WICHTIG: Nur Flag setzen, wenn NICHT programmatisch gescrollt wird
                        // Wenn isQuillScrollingProgrammatically gesetzt ist, dann wurde programmatisch gescrollt
                        // und wir sollten NICHT zurück zum Editor synchronisieren
                        if (!window.isQuillScrollingProgrammatically) {
                            // Benutzer scrollt manuell - synchronisiere zum Editor
                            var scrollTop = scrollContainer.scrollTop;
                            var scrollHeight = scrollContainer.scrollHeight - scrollContainer.clientHeight;
                            sendScrollToJava(scrollTop, scrollHeight);
                        } else {
                            // Programmatisches Scrollen - ignoriere für Synchronisation
                            // Das Flag wird von scrollQuillToText gesetzt und zurückgesetzt
                        }
                    });
                }
            }, 100);
        }
        
        // Globale Funktionen für Java-Aufrufe
        // WICHTIG: Flag für programmatische Updates - verhindert Feedback-Schleife
        window.isUpdatingFromCodeArea = false;
        
        window.setQuillContent = function(htmlContent) {
            if (!quill) {
                logToJava('ERROR', 'Quill ist nicht initialisiert!');
                return 'not_ready';
            }
            
            logToJava('DEBUG', 'setQuillContent aufgerufen, HTML-Länge: ' + (htmlContent ? htmlContent.length : 0));
            
            try {
                // WICHTIG: Setze Flag GANZ AM ANFANG, um text-change Events während des Updates zu ignorieren
                // Dies muss VOR allen Quill-Operationen gesetzt werden
                window.isUpdatingFromCodeArea = true;
                logToJava('DEBUG', 'isUpdatingFromCodeArea auf true gesetzt');
                
                var newContent = htmlContent ? htmlContent.trim() : '';
                var currentContent = quill.root.innerHTML.trim();
                
                // WICHTIG: Immer setzen beim ersten Laden oder wenn sich Content geändert hat
                if (currentContent !== newContent || currentContent === '<p><br></p>' || currentContent === '') {
                    logToJava('DEBUG', 'Setze Quill Content (alt: ' + currentContent.length + ', neu: ' + newContent.length + ')');
                    
                    // WICHTIG: Speichere Scroll-Position VOR dem Content-Update
                    var editor = document.querySelector('.ql-editor');
                    var savedScrollTop = 0;
                    var savedScrollHeight = 0;
                    if (editor) {
                        savedScrollTop = editor.scrollTop;
                        savedScrollHeight = editor.scrollHeight - editor.clientHeight;
                    }
                    
                    var success = false;
                    
                    // Methode 1: Versuche dangerouslyPasteHTML (beste Methode für Quill)
                    try {
                        // Lösche zuerst den aktuellen Inhalt - verwende getLength() - 1, da Quill immer ein '\n' am Ende hat
                        // WICHTIG: Flag muss bereits gesetzt sein (wird in setQuillContent() am Anfang gesetzt)
                        // Verwende 'silent', um keine Events auszulösen
                        var length = quill.getLength();
                        if (length > 1) {
                            // WICHTIG: Stelle sicher, dass Flag gesetzt ist, bevor deleteText aufgerufen wird
                            if (!window.isUpdatingFromCodeArea) {
                                window.isUpdatingFromCodeArea = true;
                                logToJava('WARN', 'isUpdatingFromCodeArea war nicht gesetzt, setze es jetzt');
                            }
                            quill.deleteText(0, length - 1, 'silent');
                        }
                        
                        // Konvertiere benutzerdefinierte Farb-Tags zu Quill-Format
                        // <red>Text</red> -> <span style="color: red">Text</span>
                        var convertedContent = newContent;
                        if (convertedContent) {
                            // Englische Farb-Tags
                            convertedContent = convertedContent.replace(/<red>(.*?)<\/red>/gi, '<span style="color: red">$1</span>');
                            convertedContent = convertedContent.replace(/<blue>(.*?)<\/blue>/gi, '<span style="color: blue">$1</span>');
                            convertedContent = convertedContent.replace(/<green>(.*?)<\/green>/gi, '<span style="color: green">$1</span>');
                            convertedContent = convertedContent.replace(/<yellow>(.*?)<\/yellow>/gi, '<span style="color: yellow">$1</span>');
                            convertedContent = convertedContent.replace(/<purple>(.*?)<\/purple>/gi, '<span style="color: purple">$1</span>');
                            convertedContent = convertedContent.replace(/<orange>(.*?)<\/orange>/gi, '<span style="color: orange">$1</span>');
                            convertedContent = convertedContent.replace(/<gray>(.*?)<\/gray>/gi, '<span style="color: gray">$1</span>');
                            convertedContent = convertedContent.replace(/<grey>(.*?)<\/grey>/gi, '<span style="color: gray">$1</span>');
                            // Deutsche Farb-Tags
                            convertedContent = convertedContent.replace(/<rot>(.*?)<\/rot>/gi, '<span style="color: red">$1</span>');
                            convertedContent = convertedContent.replace(/<blau>(.*?)<\/blau>/gi, '<span style="color: blue">$1</span>');
                            convertedContent = convertedContent.replace(/<grün>(.*?)<\/grün>/gi, '<span style="color: green">$1</span>');
                            convertedContent = convertedContent.replace(/<gelb>(.*?)<\/gelb>/gi, '<span style="color: yellow">$1</span>');
                            convertedContent = convertedContent.replace(/<lila>(.*?)<\/lila>/gi, '<span style="color: purple">$1</span>');
                            convertedContent = convertedContent.replace(/<grau>(.*?)<\/grau>/gi, '<span style="color: gray">$1</span>');
                            // Stelle sicher, dass <s> Tags (Strikethrough) von Quill erkannt werden
                            // Quill erkennt <s> und <del> Tags automatisch
                            // Stelle sicher, dass <mark> Tags (Highlight) von Quill erkannt werden
                            // Quill erkennt <mark> Tags, aber wir müssen sicherstellen, dass background-color gesetzt ist
                            convertedContent = convertedContent.replace(/<mark>(.*?)<\/mark>/gi, '<mark style="background-color: yellow">$1</mark>');
                            
                            // WICHTIG: Stelle sicher, dass zentrierte Absätze von Quill erkannt werden
                            // Konvertiere <p style="text-align: center;"> zu Quill-Format <p class="ql-align-center">
                            // Quill erkennt das align-Modul besser, wenn class statt style verwendet wird
                            var beforeReplace = convertedContent;
                            convertedContent = convertedContent.replace(/<p([^>]*)style="[^"]*text-align:\s*center[^"]*"([^>]*)>(.*?)<\/p>/gi, function(match, before, after, content) {
                                logToJava('DEBUG', 'Zentrierung gefunden: ' + match.substring(0, Math.min(50, match.length)));
                                // Entferne style-Attribut und füge class hinzu
                                var newBefore = before.replace(/style="[^"]*"/gi, '').trim();
                                var newAfter = after.replace(/style="[^"]*"/gi, '').trim();
                                var classAttr = 'class="ql-align-center"';
                                var result;
                                if (newBefore.includes('class=')) {
                                    // Füge ql-align-center zur bestehenden class hinzu
                                    newBefore = newBefore.replace(/class="([^"]*)"/gi, 'class="$1 ql-align-center"');
                                    result = '<p' + newBefore + newAfter + '>' + content + '</p>';
                                } else {
                                    result = '<p' + newBefore + ' ' + classAttr + newAfter + '>' + content + '</p>';
                                }
                                logToJava('DEBUG', 'Zentrierung konvertiert zu: ' + result.substring(0, Math.min(50, result.length)));
                                return result;
                            });
                            if (beforeReplace !== convertedContent) {
                                logToJava('DEBUG', 'Zentrierung wurde konvertiert, Anzahl gefundener Absätze: ' + (beforeReplace.match(/text-align:\s*center/gi) || []).length);
                            }
                            
                        }
                        
                        // Dann füge neuen Content hinzu
                        if (convertedContent && convertedContent !== '') {
                            // WICHTIG: Stelle sicher, dass <hr> Tags nicht entfernt werden
                            // Konvertiere <p><hr></p> zu <hr> (Quill erwartet <hr> ohne Wrapper)
                            convertedContent = convertedContent.replace(/<p>\s*<hr[^>]*>\s*<\/p>/gi, '<hr>');
                            // Konvertiere <div> mit border-top zu <hr> (für Kompatibilität)
                            convertedContent = convertedContent.replace(/<div[^>]*style="[^"]*border-top[^"]*"[^>]*>\s*&nbsp;\s*<\/div>/gi, '<hr>');
                            convertedContent = convertedContent.replace(/<div[^>]*style="[^"]*border-top[^"]*"[^>]*><\/div>/gi, '<hr>');
                            
                            // WICHTIG: Flag muss bereits gesetzt sein, bevor dangerouslyPasteHTML aufgerufen wird
                            // dangerouslyPasteHTML mit 'silent' sollte keine Events auslösen, aber sicherheitshalber
                            // ist das Flag bereits gesetzt
                            quill.clipboard.dangerouslyPasteHTML(0, convertedContent, 'silent');
                           
                            // WICHTIG: Nach dem Einfügen prüfen, ob <hr> Tags vorhanden sind und ggf. korrigieren
                            // WICHTIG: Flag bleibt während dieser DOM-Operationen gesetzt
                            setTimeout(function() {
                                // Stelle sicher, dass Flag noch gesetzt ist (sollte sein, aber zur Sicherheit)
                                if (!window.isUpdatingFromCodeArea) {
                                    window.isUpdatingFromCodeArea = true;
                                }
                                
                                var editor = quill.root;
                                var hrElements = editor.querySelectorAll('hr');
                                if (hrElements.length > 0) {
                                    logToJava('DEBUG', 'hr-Elemente gefunden nach dangerouslyPasteHTML: ' + hrElements.length);
                                    // Stelle sicher, dass alle hr-Elemente das richtige Styling haben
                                    hrElements.forEach(function(hr) {
                                        if (!hr.hasAttribute('style')) {
                                            hr.setAttribute('style', 'border: none; border-top: 2px solid #bdc3c7; margin: 20px 0; height: 0; overflow: hidden; display: block; width: 100%;');
                                        }
                                    });
                                }
                                
                                // WICHTIG: Nur CSS für Zentrierung anwenden - KEINE formatLine/formatText Calls!
                                // Diese blockieren den Editor und verursachen Performance-Probleme
                                var centerParagraphs = editor.querySelectorAll('p.ql-align-center, p[style*="text-align: center"]');
                                centerParagraphs.forEach(function(p) {
                                    if (p.style.textAlign !== 'center') {
                                        p.style.textAlign = 'center';
                                        p.style.setProperty('text-align', 'center', 'important');
                                    }
                                    if (!p.classList.contains('ql-align-center')) {
                                        p.classList.add('ql-align-center');
                                    }
                                });
                            }, 10);
                            
                            // WICHTIG: Stelle Scroll-Position wieder her
                            // WICHTIG: Flag bleibt während dieser Operation gesetzt
                            setTimeout(function() {
                                // Stelle sicher, dass Flag noch gesetzt ist
                                if (!window.isUpdatingFromCodeArea) {
                                    window.isUpdatingFromCodeArea = true;
                                }
                                
                                if (editor && savedScrollHeight > 0) {
                                    // Berechne neue Scroll-Position basierend auf dem Verhältnis
                                    var newScrollHeight = editor.scrollHeight - editor.clientHeight;
                                    if (newScrollHeight > 0) {
                                        var scrollRatio = savedScrollTop / savedScrollHeight;
                                        var newScrollTop = scrollRatio * newScrollHeight;
                                        editor.scrollTop = newScrollTop;
                                    } else {
                                        // Fallback: Setze gespeicherte Position direkt
                                        editor.scrollTop = savedScrollTop;
                                    }
                                }
                            }, 50);
                            
                            // WICHTIG: Stelle sicher, dass alle Bilder geladen werden
                            // WICHTIG: Flag bleibt während dieser Operation gesetzt
                            setTimeout(function() {
                                // Stelle sicher, dass Flag noch gesetzt ist
                                if (!window.isUpdatingFromCodeArea) {
                                    window.isUpdatingFromCodeArea = true;
                                }
                                
                                var images = quill.root.querySelectorAll('img');
                                images.forEach(function(img) {
                                    // Stelle sicher, dass Bild-Elemente nicht entfernt werden
                                    if (img.src && img.src.trim() !== '') {
                                        // Erzwinge Neuladen des Bildes, falls es nicht angezeigt wird
                                        var originalSrc = img.src;
                                        img.onerror = function() {
                                            logToJava('WARN', 'Bild konnte nicht geladen werden: ' + originalSrc);
                                            // Versuche erneut zu laden
                                            setTimeout(function() {
                                                if (img.src !== originalSrc) {
                                                    img.src = originalSrc;
                                                }
                                            }, 100);
                                        };
                                        // Stelle sicher, dass das Bild sichtbar ist
                                        img.style.display = 'block';
                                        img.style.visibility = 'visible';
                                        img.style.opacity = '1';
                                    }
                                });
                                
                                // Stelle Scroll-Position nochmal wieder her (nach Bild-Laden)
                                if (editor && savedScrollHeight > 0) {
                                    var newScrollHeight = editor.scrollHeight - editor.clientHeight;
                                    if (newScrollHeight > 0) {
                                        var scrollRatio = savedScrollTop / savedScrollHeight;
                                        var newScrollTop = scrollRatio * newScrollHeight;
                                        editor.scrollTop = newScrollTop;
                                    }
                                }
                            }, 100);
                        } else {
                            // Leerer Content - setze zumindest einen leeren Paragraph
                            // WICHTIG: Verwende 'silent', um kein Event auszulösen
                            quill.setText('\n', 'silent');
                        }
                        logToJava('DEBUG', 'Content gesetzt via dangerouslyPasteHTML, neue Länge: ' + quill.getLength());
                        success = true;
                        
                        // WICHTIG: Setze Flag erst NACH allen setTimeout-Operationen zurück
                        // Die längste setTimeout-Operation ist 100ms, also warten wir 250ms + Puffer
                        setTimeout(function() {
                            window.isUpdatingFromCodeArea = false;
                            logToJava('DEBUG', 'isUpdatingFromCodeArea zurückgesetzt nach dangerouslyPasteHTML (alle DOM-Operationen abgeschlossen)');
                        }, 250);
                    } catch (e1) {
                        logToJava('WARN', 'dangerouslyPasteHTML fehlgeschlagen, versuche innerHTML: ' + e1.message);
                        // Methode 2: Fallback zu innerHTML
                        try {
                            var convertedContent = newContent;
                            if (convertedContent) {
                                convertedContent = convertedContent.replace(/<red>(.*?)<\/red>/gi, '<span style="color: red">$1</span>');
                                convertedContent = convertedContent.replace(/<blue>(.*?)<\/blue>/gi, '<span style="color: blue">$1</span>');
                                convertedContent = convertedContent.replace(/<green>(.*?)<\/green>/gi, '<span style="color: green">$1</span>');
                                convertedContent = convertedContent.replace(/<yellow>(.*?)<\/yellow>/gi, '<span style="color: yellow">$1</span>');
                                convertedContent = convertedContent.replace(/<purple>(.*?)<\/purple>/gi, '<span style="color: purple">$1</span>');
                                convertedContent = convertedContent.replace(/<orange>(.*?)<\/orange>/gi, '<span style="color: orange">$1</span>');
                                convertedContent = convertedContent.replace(/<gray>(.*?)<\/gray>/gi, '<span style="color: gray">$1</span>');
                            }
                            // WICHTIG: Setze innerHTML nur wenn Flag gesetzt ist (verhindert Event)
                            if (window.isUpdatingFromCodeArea) {
                                quill.root.innerHTML = convertedContent || '<p><br></p>';
                            }
                            
                            // WICHTIG: Stelle Scroll-Position wieder her
                            setTimeout(function() {
                                if (editor && savedScrollHeight > 0) {
                                    var newScrollHeight = editor.scrollHeight - editor.clientHeight;
                                    if (newScrollHeight > 0) {
                                        var scrollRatio = savedScrollTop / savedScrollHeight;
                                        var newScrollTop = scrollRatio * newScrollHeight;
                                        editor.scrollTop = newScrollTop;
                                    } else {
                                        editor.scrollTop = savedScrollTop;
                                    }
                                }
                            }, 50);
                            
                            logToJava('DEBUG', 'Content gesetzt via innerHTML');
                            success = true;
                            
                            // WICHTIG: Setze Flag nach innerHTML-Fallback zurück (mit Verzögerung für setTimeout)
                            // innerHTML kann Events auslösen, daher etwas länger warten
                            setTimeout(function() {
                                window.isUpdatingFromCodeArea = false;
                                logToJava('DEBUG', 'isUpdatingFromCodeArea zurückgesetzt nach innerHTML-Fallback');
                            }, 300);
                        } catch (e2) {
                            logToJava('ERROR', 'Auch innerHTML fehlgeschlagen: ' + e2.message);
                            // Methode 3: Letzter Fallback - setText
                            try {
                                var textContent = newContent.replace(/<[^>]+>/g, '').replace(/&nbsp;/g, ' ');
                                // WICHTIG: Verwende 'silent', um kein Event auszulösen
                                quill.setText(textContent, 'silent');
                                logToJava('DEBUG', 'Content gesetzt via setText (nur Text)');
                                success = true;
                            } catch (e3) {
                                logToJava('ERROR', 'Alle Methoden fehlgeschlagen: ' + e3.message);
                                return 'error: ' + e3.message;
                            }
                        }
                    }
                    
                    if (success) {
                        // Stelle sicher, dass Editor sichtbar ist
                        setTimeout(function() {
                            var editor = document.querySelector('.ql-editor');
                            if (editor) {
                                editor.style.display = 'block';
                                editor.style.visibility = 'visible';
                                editor.style.opacity = '1';
                                
                                // Prüfe ob Content wirklich sichtbar ist
                                var actualContent = quill.root.innerHTML;
                                logToJava('DEBUG', 'Verifizierung: Tatsächlicher Content-Länge: ' + actualContent.length);
                                
                                if (actualContent.length === 0 || actualContent === '<p><br></p>') {
                                    logToJava('WARN', 'Content scheint leer zu sein, versuche erneut...');
                                    // Versuche nochmal mit direkter Methode
                                    var convertedContent = newContent;
                                    if (convertedContent) {
                                        convertedContent = convertedContent.replace(/<red>(.*?)<\/red>/gi, '<span style="color: red">$1</span>');
                                        convertedContent = convertedContent.replace(/<blue>(.*?)<\/blue>/gi, '<span style="color: blue">$1</span>');
                                        convertedContent = convertedContent.replace(/<green>(.*?)<\/green>/gi, '<span style="color: green">$1</span>');
                                        convertedContent = convertedContent.replace(/<yellow>(.*?)<\/yellow>/gi, '<span style="color: yellow">$1</span>');
                                        convertedContent = convertedContent.replace(/<purple>(.*?)<\/purple>/gi, '<span style="color: purple">$1</span>');
                                        convertedContent = convertedContent.replace(/<orange>(.*?)<\/orange>/gi, '<span style="color: orange">$1</span>');
                                        convertedContent = convertedContent.replace(/<gray>(.*?)<\/gray>/gi, '<span style="color: gray">$1</span>');
                                    }
                                    // WICHTIG: Setze innerHTML nur wenn Flag noch gesetzt ist (sonst könnte es Event auslösen)
                                    if (window.isUpdatingFromCodeArea) {
                                        quill.root.innerHTML = convertedContent || '<p><br></p>';
                                    }
                                }
                            }
                        }, 100);
                        
                        // WICHTIG: Setze Flag nach Verifizierung zurück (falls noch nicht zurückgesetzt)
                        // Dies ist ein Fallback, falls das Flag noch nicht zurückgesetzt wurde
                        setTimeout(function() {
                            if (window.isUpdatingFromCodeArea) {
                                window.isUpdatingFromCodeArea = false;
                                logToJava('DEBUG', 'isUpdatingFromCodeArea zurückgesetzt nach Verifizierung (Fallback)');
                            }
                        }, 400);
                        
                        return 'success';
                    }
                } else {
                    logToJava('DEBUG', 'Quill Content unverändert, keine Aktualisierung nötig');
                    // WICHTIG: Flag auch zurücksetzen, wenn kein Update nötig war
                    window.isUpdatingFromCodeArea = false;
                    return 'success'; // Content war bereits korrekt
                }
            } catch (e) {
                logToJava('ERROR', 'Fehler beim Setzen des Quill Contents: ' + e.message);
                // WICHTIG: Flag auch bei Fehler zurücksetzen
                window.isUpdatingFromCodeArea = false;
                return 'error: ' + e.message;
            }
            
            // WICHTIG: Fallback - Flag zurücksetzen falls wir hier ankommen
            window.isUpdatingFromCodeArea = false;
            return 'success';
        };
        
        window.setQuillDelta = function(deltaJson) {
            try {
                if (!quill) {
                    logToJava('ERROR', 'Quill ist nicht initialisiert!');
                    return;
                }
                var delta = JSON.parse(deltaJson);
                quill.setContents(delta, 'api');
            } catch (e) {
                logToJava('ERROR', 'Error setting Quill delta: ' + e.message);
            }
        };
        
        window.applyQuillTheme = function(css) {
            var styleElement = document.getElementById('theme-styles');
            if (styleElement) {
                // Extrahiere Textfarbe aus dem CSS
                var textColor = '#444';
                var textColorMatch = css.match(/\.ql-editor\s*\{[^}]*color:\s*([^;!]+)/);
                if (textColorMatch) {
                    textColor = textColorMatch[1].trim();
                }
                
                // Bestimme ob dunkles Theme
                var isDarkTheme = textColor === '#ffffff' || textColor === '#fff' || textColor.toLowerCase().includes('white');
                // Label-Farbe sollte genau der Textfarbe entsprechen, nicht grau!
                var labelColor = isDarkTheme ? '#ffffff' : '#000000';
                var dropdownBg = isDarkTheme ? '#333' : '#fff';
                var dropdownTextColor = isDarkTheme ? '#fff' : '#444';
                var hoverBg = isDarkTheme ? 'rgba(255,255,255,0.1)' : '#f0f0f0';
                var selectedBg = isDarkTheme ? 'rgba(255,255,255,0.2)' : '#e0e0e0';
                
                // STÄRKERE Regeln für Dropdown-Labels - müssen alle Selektoren abdecken
                var dropdownCss = " .ql-toolbar .ql-picker-label { color: " + labelColor + " !important; } ";
                dropdownCss += " .ql-toolbar .ql-picker-label * { color: " + labelColor + " !important; } ";
                dropdownCss += " .ql-toolbar .ql-color .ql-picker-label, .ql-toolbar .ql-background .ql-picker-label, .ql-toolbar .ql-font .ql-picker-label, .ql-toolbar .ql-size .ql-picker-label, .ql-toolbar .ql-align .ql-picker-label, .ql-toolbar .ql-header .ql-picker-label { color: " + labelColor + " !important; } ";
                dropdownCss += " .ql-toolbar .ql-color .ql-picker-label *, .ql-toolbar .ql-background .ql-picker-label *, .ql-toolbar .ql-font .ql-picker-label *, .ql-toolbar .ql-size .ql-picker-label *, .ql-toolbar .ql-align .ql-picker-label *, .ql-toolbar .ql-header .ql-picker-label * { color: " + labelColor + " !important; } ";
                dropdownCss += " .ql-toolbar .ql-picker-label svg { fill: " + labelColor + " !important; stroke: " + labelColor + " !important; } ";
                dropdownCss += " .ql-toolbar .ql-picker-label svg * { fill: " + labelColor + " !important; stroke: " + labelColor + " !important; } ";
                dropdownCss += " .ql-toolbar .ql-picker-options { background-color: " + dropdownBg + " !important; border: 1px solid #ccc !important; box-shadow: 0 2px 8px rgba(0,0,0,0.15) !important; } ";
                dropdownCss += " .ql-toolbar .ql-picker-options .ql-picker-item { color: " + dropdownTextColor + " !important; } ";
                dropdownCss += " .ql-toolbar .ql-picker-item:hover { background-color: " + hoverBg + " !important; } ";
                dropdownCss += " .ql-toolbar .ql-picker-item.ql-selected { background-color: " + selectedBg + " !important; } ";
                
                // WICHTIG: Theme kann text-align: left !important setzen und Quill-Ausrichtung überschreiben.
                // Deshalb erzwingen wir Quill-Align-Klassen explizit mit !important (center/right/justify/left).
                var alignOverrideCss = "";
                // WICHTIG: text-align-last kann text-align bei einzeiligen Absätzen überstimmen → immer mitsetzen
                alignOverrideCss += " .ql-editor .ql-align-center, .ql-editor p.ql-align-center, .ql-editor div.ql-align-center, .ql-editor li.ql-align-center, .ql-editor blockquote.ql-align-center { text-align: center !important; text-align-last: center !important; } ";
                alignOverrideCss += " .ql-editor .ql-align-right, .ql-editor p.ql-align-right, .ql-editor div.ql-align-right, .ql-editor li.ql-align-right, .ql-editor blockquote.ql-align-right { text-align: right !important; text-align-last: right !important; } ";
                alignOverrideCss += " .ql-editor .ql-align-justify, .ql-editor p.ql-align-justify, .ql-editor div.ql-align-justify, .ql-editor li.ql-align-justify, .ql-editor blockquote.ql-align-justify { text-align: justify !important; text-align-last: left !important; } ";
                alignOverrideCss += " .ql-editor .ql-align-left, .ql-editor p.ql-align-left, .ql-editor div.ql-align-left, .ql-editor li.ql-align-left, .ql-editor blockquote.ql-align-left { text-align: left !important; text-align-last: left !important; } ";
                
                styleElement.textContent = css + dropdownCss + alignOverrideCss;
                
                // Zusätzlich: Direkt auf die Elemente zugreifen und Farbe setzen (für sofortige Wirkung)
                setTimeout(function() {
                    var labels = document.querySelectorAll('.ql-toolbar .ql-picker-label');
                    labels.forEach(function(label) {
                        // Setze Farbe auf Label selbst
                        label.style.setProperty('color', labelColor, 'important');
                        // Setze Farbe auf alle Text-Knoten
                        var walker = document.createTreeWalker(label, NodeFilter.SHOW_TEXT, null, false);
                        var node;
                        while (node = walker.nextNode()) {
                            if (node.parentElement) {
                                node.parentElement.style.setProperty('color', labelColor, 'important');
                            }
                        }
                        // Setze Farbe auf alle SVG-Elemente
                        var svgs = label.querySelectorAll('svg, svg *');
                        svgs.forEach(function(svg) {
                            svg.style.setProperty('fill', labelColor, 'important');
                            svg.style.setProperty('stroke', labelColor, 'important');
                        });
                        // Setze Farbe auf alle SPAN-Elemente innerhalb des Labels
                        var spans = label.querySelectorAll('span');
                        spans.forEach(function(span) {
                            span.style.setProperty('color', labelColor, 'important');
                        });
                    });
                }, 150);
            } else {
                logToJava('ERROR', 'Theme-Style-Element nicht gefunden!');
            }
        };
        
        window.setQuillGlobalFontSize = function(fontSize) {
            if (!quill) {
                logToJava('ERROR', 'Quill ist nicht initialisiert!');
                return;
            }
            try {
                // Setze globale Schriftgröße für den gesamten Editor
                var editor = document.querySelector('.ql-editor');
                var container = document.querySelector('.ql-container');
                
                if (editor) {
                    // WICHTIG: Setze Basis-Schriftgröße direkt, OHNE proportionale Skalierung
                    // Die proportionale Skalierung führte zu falschen Werten
                    editor.style.setProperty('font-size', fontSize + 'px', 'important');
                    
                    // Setze auch auf Container
                    if (container) {
                        container.style.setProperty('font-size', fontSize + 'px', 'important');
                    }
                    
                    logToJava('DEBUG', 'Quill globale Schriftgröße gesetzt auf: ' + fontSize + 'px');
                }
            } catch (e) {
                logToJava('ERROR', 'Fehler beim Setzen der Quill globalen Schriftgröße: ' + e.message);
            }
        };
        
        window.setQuillGlobalFontFamily = function(fontFamily) {
            if (!quill) {
                logToJava('ERROR', 'Quill ist nicht initialisiert!');
                return;
            }
            try {
                // Setze globale Schriftart für den gesamten Editor
                var editor = document.querySelector('.ql-editor');
                var container = document.querySelector('.ql-container');
                
                if (editor) {
                    // WICHTIG: Setze Basis-Schriftart mit !important, damit sie nicht überschrieben wird
                    editor.style.setProperty('font-family', fontFamily, 'important');
                    
                    // Ändere ALLE Elemente - auch die mit inline styles
                    var allElements = editor.querySelectorAll('*');
                    allElements.forEach(function(el) {
                        // Überschreibe IMMER, auch wenn bereits eine Font-Formatierung vorhanden ist
                        el.style.setProperty('font-family', fontFamily, 'important');
                    });
                }
                
                if (container) {
                    container.style.setProperty('font-family', fontFamily, 'important');
                }
                
                logToJava('DEBUG', 'Quill globale Schriftart gesetzt auf: ' + fontFamily);
            } catch (e) {
                logToJava('ERROR', 'Fehler beim Setzen der Quill globalen Schriftart: ' + e.message);
            }
        };
        
        
window.scrollQuillTo = function(scrollTop) {
    // Bevorzugt den Container (.ql-container), fallback auf .ql-editor
    var container = document.querySelector('.ql-container');
    var editor = document.querySelector('.ql-editor');
    var scroller = container || editor;
    if (scroller) {
        scroller.scrollTop = scrollTop;
    }
};
        
        // Textbasierte Scroll-Hilfen
        window.getMiddleVisibleText = function() {
            var editor = document.querySelector('.ql-editor');
            if (!editor) return '';
            
            var scrollTop = editor.scrollTop;
            var visibleHeight = editor.clientHeight;
            var midPixel = scrollTop + visibleHeight / 2;
            
            // Finde das Element, das in der Mitte des Viewports ist
            var elements = editor.querySelectorAll('p, div, h1, h2, h3, blockquote, li');
            var foundElement = null;
            var minDistance = Infinity;
            
            for (var i = 0; i < elements.length; i++) {
                var el = elements[i];
                var elTop = el.offsetTop;
                var elBottom = elTop + el.offsetHeight;
                var elCenter = elTop + (el.offsetHeight / 2);
                
                // Berechne Abstand zur Viewport-Mitte
                var distance = Math.abs(elCenter - midPixel);
                
                // Prüfe ob Element sichtbar ist
                if (elBottom >= scrollTop && elTop <= scrollTop + visibleHeight) {
                    if (distance < minDistance) {
                        minDistance = distance;
                        foundElement = el;
                    }
                }
            }
            
            if (foundElement) {
                var text = foundElement.innerText || foundElement.textContent || '';
                text = text.trim();
                if (text.length > 3) {
                    // Nimm einen Snippet aus der Mitte des Elements
                    var mid = Math.floor(text.length / 2);
                    var start = Math.max(0, mid - 40);
                    var end = Math.min(text.length, mid + 40);
                    return text.slice(start, end).trim();
                }
            }
            
            // Fallback: Verwende Prozent-basierte Methode
            var text = editor.innerText || '';
            if (!text) return '';
            var scrollHeight = editor.scrollHeight;
            var total = text.length;
            if (scrollHeight <= visibleHeight || total === 0) {
                var midIdx = Math.floor(total / 2);
                return text.slice(Math.max(0, midIdx - 40), Math.min(total, midIdx + 40)).trim();
            }
            var percent = midPixel / scrollHeight;
            var charIdx = Math.min(total - 1, Math.max(0, Math.floor(percent * total)));
            return text.slice(Math.max(0, charIdx - 40), Math.min(total, charIdx + 40)).trim();
        };
        
        window.scrollQuillToText = function(snippet) {
            if (!snippet || snippet.length === 0) return false;
            // WICHTIG: Setze Flag, dass programmatisches Scrollen stattfindet
            // Verwende separates Flag für programmatisches Scrollen
            window.isQuillScrollingProgrammatically = true;
            clearTimeout(window.quillScrollingProgrammaticallyTimeout);
            
            var editor = document.querySelector('.ql-editor');
            if (!editor) {
                window.isQuillScrolling = false;
                return false;
            }
            
            // Suche nach dem Text im DOM, nicht nur im innerText
            var text = editor.innerText || '';
            var idx = text.indexOf(snippet);
            if (idx < 0) return false;
            
            // Finde das DOM-Element, das den Text enthält
            // Durchsuche alle Textknoten und finde den, der den Snippet enthält
            var walker = document.createTreeWalker(
                editor,
                NodeFilter.SHOW_TEXT,
                null,
                false
            );
            
            var node;
            var charCount = 0;
            var foundNode = null;
            var foundOffset = -1;
            
            while (node = walker.nextNode()) {
                var nodeText = node.textContent || '';
                var nodeStart = charCount;
                var nodeEnd = charCount + nodeText.length;
                
                if (idx >= nodeStart && idx < nodeEnd) {
                    foundNode = node;
                    foundOffset = idx - nodeStart;
                    break;
                }
                
                charCount = nodeEnd;
            }
            
            if (!foundNode) {
                // Fallback: Verwende Prozent-basierte Berechnung
                var total = text.length;
                var scrollContainer = editor;
                var scrollHeight = scrollContainer.scrollHeight - scrollContainer.clientHeight;
                if (total === 0 || scrollHeight <= 0) return false;
                var percent = idx / total;
                scrollContainer.scrollTop = percent * scrollHeight;
                return true;
            }
            
            // WICHTIG: Setze Flag länger zurück (500ms), damit Polling-Mechanismus Zeit hat,
            // das Flag zu erkennen und Rückkopplung zu verhindern
            window.quillScrollingProgrammaticallyTimeout = setTimeout(function() {
                window.isQuillScrollingProgrammatically = false;
            }, 500);
            
            // Finde das übergeordnete Block-Element (p, div, etc.)
            var blockElement = foundNode.parentElement;
            while (blockElement && blockElement !== editor) {
                var tagName = blockElement.tagName.toLowerCase();
                if (tagName === 'p' || tagName === 'div' || tagName === 'h1' || 
                    tagName === 'h2' || tagName === 'h3' || tagName === 'blockquote') {
                    // Zentriere dieses Element im Viewport
                    var containerHeight = editor.clientHeight;
                    var elementTop = blockElement.offsetTop;
                    var elementHeight = blockElement.offsetHeight;
                    var scrollTop = elementTop - (containerHeight / 2) + (elementHeight / 2);
                    editor.scrollTop = Math.max(0, scrollTop);
                    return true;
                }
                blockElement = blockElement.parentElement;
            }
            
            // Fallback: Prozent-basiert
            var total = text.length;
            var scrollContainer = editor;
            var scrollHeight = scrollContainer.scrollHeight - scrollContainer.clientHeight;
            if (total === 0 || scrollHeight <= 0) return false;
            var percent = idx / total;
            scrollContainer.scrollTop = percent * scrollHeight;
            return true;
        };
        
        window.getQuillContent = function() {
            if (quill) {
                return quill.root.innerHTML;
            }
            return '';
        };
        
        window.getQuillDelta = function() {
            if (quill) {
                return JSON.stringify(quill.getContents());
            }
            return '{}';
        };
        
        window.getQuillText = function() {
            if (quill) {
                return quill.getText();
            }
            return '';
        };
        
        // Initialisiere Flags für Polling
        window.quillContentChanged = false;
        window.quillSelectionChanged = false;
        window.quillScrollChanged = false;
        window.quillLastContent = null;
        window.quillLastDelta = null;
        window.quillLastSelection = null;
        window.quillLastScroll = null;
        
        // Initialisiere quillLogs Array
        if (!window.quillLogs) {
            window.quillLogs = [];
        }
        
        // Test-Log direkt beim Start
        logToJava('INFO', 'Quill Editor initialisiert - Test-Log');
        
        // Signalisiere, dass Quill bereit ist
        window.quillReady = true;
        
        // Debug: Prüfe ob Quill richtig geladen wurde
        if (typeof Quill === 'undefined') {
            logToJava('ERROR', 'Quill wurde nicht geladen!');
            // Versuche nach kurzer Verzögerung erneut
            setTimeout(function() {
                if (typeof Quill === 'undefined') {
                    logToJava('ERROR', 'Quill konnte auch nach Verzögerung nicht geladen werden!');
                    document.getElementById('error-message').style.display = 'block';
                    document.getElementById('error-message').innerHTML = 
                        '<h2>Fehler beim Laden des Quill Editors</h2>' +
                        '<p>Die Quill-Bibliothek konnte nicht geladen werden.</p>' +
                        '<p>Bitte prüfen Sie Ihre Internet-Verbindung oder kontaktieren Sie den Administrator.</p>';
                } else {
                    logToJava('INFO', 'Quill wurde nach Verzögerung geladen');
                    // Initialisiere Quill jetzt
                    try {
                        quill = new Quill('#editor', {
                            theme: 'snow',
                            modules: {
                                toolbar: [
                                    [{ 'font': [] }],
                                    [{ 'size': ['small', false, 'large', 'huge'] }],
                                    ['bold', 'italic', 'underline', 'strike'],
                                    [{ 'script': 'sub'}, { 'script': 'super' }],
                                    ['blockquote', 'code-block'],
                                    [{ 'align': [] }],
                                    ['link'],
                                    ['clean']
                                ]
                            }
                        });
                        window.quillReady = true;
                        logToJava('INFO', 'Quill Editor nach Verzögerung initialisiert');
                    } catch (e) {
                        logToJava('ERROR', 'Fehler beim Initialisieren von Quill nach Verzögerung: ' + e.message);
                    }
                }
            }, 2000);
        } else {
            logToJava('INFO', 'Quill Version: ' + Quill.version);
            window.quillReady = true;
        }
    </script>
</body>
</html>

